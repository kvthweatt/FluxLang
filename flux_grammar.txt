# Flux Language BNF Grammar

```bnf
(* ====================================================================== *)
(*                           FLUX LANGUAGE BNF                           *)
(* ====================================================================== *)

(* Program Structure *)
<program> ::= <global_item>* <main_function>

<global_item> ::= <function_definition>
                | <object_definition>
                | <struct_definition>
                | <namespace_definition>
                | <template_definition>
                | <import_statement>
                | <using_statement>
                | <variable_declaration>

<main_function> ::= "def" "main" "(" ")" "->" "int" "{" <statement_list> "}"

(* Import and Using *)
<import_statement> ::= "import" <string_literal> "as" <identifier> ";"
                     | "import" <string_literal> ";"

<using_statement> ::= "using" <namespace_path_list> ";"

<namespace_path_list> ::= <namespace_path> ("," <namespace_path>)*

<namespace_path> ::= <identifier> ("::" <identifier>)*

(* Function Definitions *)
<function_definition> ::= <function_modifier>* "def" <identifier> "(" <parameter_list>? ")" "->" <type_specifier> "{" <statement_list> "}"

<function_modifier> ::= "volatile"

<parameter_list> ::= <parameter> ("," <parameter>)*

<parameter> ::= <type_specifier> <identifier>

(* Template Definitions *)
<template_definition> ::= <template_modifier>* "template" "<" <template_parameter_list> ">" <identifier> "(" <parameter_list>? ")" "->" <type_specifier> "{" <statement_list> "}"

<template_modifier> ::= "volatile"

<template_parameter_list> ::= <identifier> ("," <identifier>)*

(* Object Definitions *)
<object_definition> ::= "object" <identifier> <inheritance>? "{" <object_member_list>? "}"

<inheritance> ::= ":" <identifier> ("," <identifier>)*

<object_member_list> ::= <object_member>*

<object_member> ::= <variable_declaration>
                  | <function_definition>
                  | <magic_method_definition>
                  | <object_definition>

<magic_method_definition> ::= "def" <magic_method_name> "(" <parameter_list>? ")" "->" <type_specifier> "{" <statement_list> "}"

<magic_method_name> ::= "__new" | "__init" | "__exit" | "__expr" | "__eq" | "__ee" | "__ne" 
                      | "__le" | "__ge" | "__lt" | "__gt" | "__add" | "__sub" | "__inc" | "__dec"
                      | "__mul" | "__div" | "__iadd" | "__isub" | "__imul" | "__idiv" | "__mod"
                      | "__pow" | "__imod" | "__ipow" | "__ls" | "__rs" | "__and" | "__or" | "__xor"
                      | "__nand" | "__nor" | "__xand" | "__xnor" | "__xnand" | "__band" | "__bor"
                      | "__bxor" | "__bnand" | "__bnor" | "__bxand" | "__bxnor" | "__bxnand"
                      | "__andeq" | "__oreq" | "__xoreq" | "__nandeq" | "__noreq" | "__xandeq"
                      | "__xnoreq" | "__xnandeq" | "__bandeq" | "__boreq" | "__bxoreq"
                      | "__bnandeq" | "__bnoreq" | "__bxandeq" | "__bxnoreq" | "__bxnandeq"

(* Struct Definitions *)
<struct_definition> ::= "struct" <identifier> "{" <struct_member_list>? "}"

<struct_member_list> ::= <struct_member>*

<struct_member> ::= <variable_declaration>

(* Namespace Definitions *)
<namespace_definition> ::= "namespace" <identifier> "{" <namespace_member_list>? "}"

<namespace_member_list> ::= <namespace_member>*

<namespace_member> ::= <function_definition>
                     | <object_definition>
                     | <struct_definition>
                     | <template_definition>
                     | <variable_declaration>

(* Type Specifiers *)
<type_specifier> ::= <basic_type>
                   | <data_type>
                   | <array_type>
                   | <pointer_type>
                   | <function_pointer_type>
                   | <template_pointer_type>
                   | <identifier>
                   | "this"
                   | "void"
                   | "auto"

<basic_type> ::= "int" | "float" | "char" | "bool" | "string"

<data_type> ::= <signedness>? "data" "{" <integer_literal> "}"

<signedness> ::= "signed" | "unsigned"

<array_type> ::= <type_specifier> "[" "]"

<pointer_type> ::= <type_specifier> "*"
                 | <array_type> "*"

<function_pointer_type> ::= <type_specifier> "(" "*" <identifier> ")" "(" <type_list>? ")"

<template_pointer_type> ::= "template" "*" <identifier>

<type_list> ::= <type_specifier> ("," <type_specifier>)*

(* Variable Declarations *)
<variable_declaration> ::= <type_specifier> <variable_declarator_list> ";"

<variable_declarator_list> ::= <variable_declarator> ("," <variable_declarator>)*

<variable_declarator> ::= <identifier> <initializer>?

<initializer> ::= "=" <expression>
                | "(" <expression_list>? ")"
                | "{" <field_initializer_list>? "}"

<field_initializer_list> ::= <field_initializer> ("," <field_initializer>)*

<field_initializer> ::= <identifier> "=" <expression>

(* Statements *)
<statement_list> ::= <statement>*

<statement> ::= <expression_statement>
              | <compound_statement>
              | <if_statement>
              | <switch_statement>
              | <while_statement>
              | <for_statement>
              | <try_statement>
              | <return_statement>
              | <throw_statement>
              | <break_statement>
              | <continue_statement>
              | <variable_declaration>
              | <assembly_block>

<expression_statement> ::= <expression>? ";"

<compound_statement> ::= "{" <statement_list> "}"

<if_statement> ::= "if" "(" <expression> ")" <statement> <else_clause>?

<else_clause> ::= "else" <statement>
                | "else" <if_statement>

<switch_statement> ::= "switch" "(" <expression> ")" "{" <case_list>? <default_clause>? "}"

<case_list> ::= <case_clause>*

<case_clause> ::= "case" "(" <expression> ")" "{" <statement_list> "}"

<default_clause> ::= "default" "{" <statement_list> "}"

<while_statement> ::= "while" "(" <expression> ")" <statement>

<for_statement> ::= "for" "(" <identifier> "in" <expression> ")" <statement>

<try_statement> ::= "try" <compound_statement> <catch_clause_list>

<catch_clause_list> ::= <catch_clause>+

<catch_clause> ::= "catch" "(" <catch_parameter> ")" <compound_statement>

<catch_parameter> ::= <type_specifier> <identifier>
                    | "auto" <identifier>

<return_statement> ::= "return" <expression>? ";"

<throw_statement> ::= "throw" "(" <expression> ")" ";"

<break_statement> ::= "break" ";"

<continue_statement> ::= "continue" ";"

<assembly_block> ::= "asm" "{" <assembly_instruction>* "}"

<assembly_instruction> ::= <identifier> <assembly_operand_list>?

<assembly_operand_list> ::= <assembly_operand> ("," <assembly_operand>)*

<assembly_operand> ::= <identifier> | <integer_literal> | <register_name>

(* Expressions - Following Precedence Table *)
<expression> ::= <conditional_expression>

<conditional_expression> ::= <logical_or_expression> ("?" <expression> ":" <conditional_expression>)?

<logical_or_expression> ::= <logical_and_expression> (<logical_or_operator> <logical_and_expression>)*

<logical_or_operator> ::= "or" | "||" | "!|"

<logical_and_expression> ::= <bitwise_or_expression> (<logical_and_operator> <bitwise_or_expression>)*

<logical_and_operator> ::= "and" | "&&" | "!&"

<bitwise_or_expression> ::= <bitwise_xor_expression> (<bitwise_or_operator> <bitwise_xor_expression>)*

<bitwise_or_operator> ::= "|" | "`|" | "`!|"

<bitwise_xor_expression> ::= <bitwise_and_expression> (<bitwise_xor_operator> <bitwise_and_expression>)*

<bitwise_xor_operator> ::= "^^" | "xor" | "`^^" | "`^!|" | "`^!&"

<bitwise_and_expression> ::= <identity_expression> (<bitwise_and_operator> <identity_expression>)*

<bitwise_and_operator> ::= "&" | "`&&" | "`!&" | "`^&"

<identity_expression> ::= <equality_expression> (<identity_operator> <equality_expression>)*

<identity_operator> ::= "is" | "not" | "as"

<equality_expression> ::= <relational_expression> (<equality_operator> <relational_expression>)*

<equality_operator> ::= "==" | "!="

<relational_expression> ::= <shift_expression> (<relational_operator> <shift_expression>)*

<relational_operator> ::= "<" | "<=" | ">" | ">=" | "in"

<shift_expression> ::= <additive_expression> (<shift_operator> <additive_expression>)*

<shift_operator> ::= "<<" | ">>"

<additive_expression> ::= <multiplicative_expression> (<additive_operator> <multiplicative_expression>)*

<additive_operator> ::= "+" | "-"

<multiplicative_expression> ::= <exponential_expression> (<multiplicative_operator> <exponential_expression>)*

<multiplicative_operator> ::= "*" | "/" | "%"

<exponential_expression> ::= <cast_expression> ("^" <exponential_expression>)?

<cast_expression> ::= "(" <type_specifier> ")" <unary_expression>
                    | <unary_expression>

<unary_expression> ::= <unary_operator> <unary_expression>
                     | <postfix_expression>

<unary_operator> ::= "++" | "--" | "+" | "-" | "!" | "~" | "@" | "*" | "not" | "sizeof" | "typeof"

<postfix_expression> ::= <primary_expression> <postfix_operator>*

<postfix_operator> ::= "[" <expression> "]"
                     | "(" <expression_list>? ")"
                     | "." <identifier>
                     | "::" <identifier>
                     | "++"
                     | "--"
                     | "<" <template_argument_list> ">"

<template_argument_list> ::= <type_specifier> ("," <type_specifier>)*

<primary_expression> ::= <identifier>
                       | <literal>
                       | <i_string>
                       | <array_literal>
                       | <array_comprehension>
                       | <destructuring_assignment>
                       | "(" <expression> ")"
                       | "this"
                       | "super" ("." <identifier>)?

(* Literals *)
<literal> ::= <integer_literal>
            | <float_literal>
            | <char_literal>
            | <string_literal>
            | <binary_literal>
            | <boolean_literal>

<integer_literal> ::= <digit>+

<float_literal> ::= <digit>+ "." <digit>+

<char_literal> ::= "\"" <character> "\""

<string_literal> ::= "\"" <character>* "\""

<binary_literal> ::= <binary_digit>+ "b"

<boolean_literal> ::= "true" | "false"

(* I-strings *)
<i_string> ::= "i" <string_literal> ":" "{" <expression_list> "}"

<expression_list> ::= <expression> (";" <expression>)*

(* Array Literals and Comprehensions *)
<array_literal> ::= "[" <expression_list>? "]"

<array_comprehension> ::= "[" <expression> "for" "(" <identifier> "in" <expression> ")" <comprehension_condition>? "]"

<comprehension_condition> ::= "if" "(" <expression> ")"

(* Destructuring *)
<destructuring_assignment> ::= "auto" "{" <identifier_list> "}" "=" <identifier> "{" <identifier_list> "}"

<identifier_list> ::= <identifier> ("," <identifier>)*

(* Assignment Expressions *)
<assignment_expression> ::= <logical_or_expression> <assignment_operator> <expression>
                           | <logical_or_expression>

<assignment_operator> ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "^^=" 
                        | "<<=" | ">>=" | "`&&=" | "`!&=" | "`|=" | "`!|=" | "`^=" | "`!="

(* Lexical Elements *)
<identifier> ::= <letter> (<letter> | <digit> | "_")*

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<binary_digit> ::= "0" | "1"

<letter> ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
           | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
           | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
           | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"

<character> ::= <letter> | <digit> | <special_character> | <escape_sequence>

<special_character> ::= " " | "!" | "#" | "$" | "%" | "&" | "'" | "(" | ")" | "*" | "+"
                      | "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" | "@"
                      | "[" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~"

<escape_sequence> ::= "\\" <escape_character>

<escape_character> ::= "n" | "t" | "r" | "\\" | "\"" | "'" | "0"

<register_name> ::= "eax" | "ebx" | "ecx" | "edx" | "esi" | "edi" | "esp" | "ebp"
                  | "ax" | "bx" | "cx" | "dx" | "si" | "di" | "sp" | "bp"
                  | "al" | "bl" | "cl" | "dl" | "ah" | "bh" | "ch" | "dh"

(* Keywords *)
<keyword> ::= "and" | "as" | "asm" | "assert" | "auto" | "break" | "bool" | "case" | "catch"
            | "const" | "continue" | "data" | "def" | "default" | "do" | "else" | "enum"
            | "false" | "float" | "for" | "if" | "import" | "in" | "int" | "is" | "namespace"
            | "not" | "object" | "or" | "return" | "signed" | "sizeof" | "struct" | "super"
            | "switch" | "template" | "this" | "throw" | "true" | "try" | "typeof" | "unsigned"
            | "using" | "void" | "volatile" | "while" | "xor"

(* Comments - Lexical Analysis Level *)
<line_comment> ::= "//" <character>* <newline>

<block_comment> ::= "/*" <any_character>* "*/"

<newline> ::= "\n" | "\r\n" | "\r"

<any_character> ::= <character> | <newline>
```

## Notes

1. **Precedence**: The expression grammar follows the precedence table exactly as specified in the language spec, from lowest (conditional) to highest (primary expressions).

2. **Operators**: All the special bitwise operators with backtick prefixes are included (`` `&& ``, `` `!& ``, etc.).

3. **Magic Methods**: All magic method names are enumerated as terminals.

4. **Templates**: Template instantiation syntax `<type>` is included in postfix expressions.

5. **I-strings**: Special interpolated string syntax is captured with expression lists.

6. **Error Handling**: Complete try/catch with multiple catch clauses and auto-typing.

7. **Function Pointers**: C++-style function pointer syntax is properly captured.

8. **Inheritance**: Object inheritance with `super` keyword access.

9. **Assembly**: Inline assembly blocks with instruction syntax.

10. **Data Types**: Variable-width data types with bit specifications.