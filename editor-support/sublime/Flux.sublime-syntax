%YAML 1.2
---
name: Flux
file_extensions: [fx]
scope: source.flux

variables:
  identifier: '\b[a-zA-Z_][a-zA-Z0-9_]*\b'
  
contexts:
  main:
    - match: '///'
      scope: punctuation.definition.comment.begin.flux
      push: multiline_comment

    # Single-line comments
    - match: '//.*$\n?'
      scope: comment.line.double-slash.flux

    # Preprocessor directives
    - match: '^\s*(#)(import|def|ifdef|ifndef|else|endif)\b'
      captures:
        1: punctuation.definition.preprocessor.flux
        2: keyword.control.preprocessor.flux
      scope: meta.preprocessor.flux

    # i-strings (interpolated strings)
    - match: 'i"'
      scope: string.quoted.double.flux punctuation.definition.string.begin.flux
      push: i_string_body

    # f-strings (formatted strings)
    - match: 'f"'
      scope: string.quoted.double.flux punctuation.definition.string.begin.flux
      push: f_string_body

    # Regular strings
    - match: '"'
      scope: string.quoted.double.flux punctuation.definition.string.begin.flux
      push: string_body

    # Character literals
    - match: "'"
      scope: string.quoted.single.flux punctuation.definition.string.begin.flux
      push: char_body

    # Namespace/scope resolution (check this BEFORE keywords)
    - match: '({{identifier}})(::)'
      captures:
        1: entity.name.namespace.flux
        2: punctuation.accessor.double-colon.flux

    # Data type definitions (must come before keywords to avoid matching 'data' keyword)
    - match: '\b(const\s+)?(signed|unsigned)?\s*data\s*\{[^}]+\}(\s*\[\])?\s+as\s+({{identifier}})'
      captures:
        1: storage.modifier.flux
        2: storage.modifier.flux
        3: storage.type.data.flux
        5: entity.name.type.flux

    # Primitive types (MUST come before keywords)
    - match: '\b(int|uint|float|void|bool|char)\b'
      scope: storage.type.primitive.flux

    # Storage types
    - match: '\b(enum|struct|object|union|trait|contract)\b'
      scope: storage.type.flux

    # Keywords (but NOT types)
    - match: '\b(alignof|and|as|asm|assert|auto|break|case|catch|contract|compt|const|continue|def|default|do|elif|else|extern|false|for|from|global|heap|if|in|is|local|namespace|not|operator|or|private|public|register|return|signed|sizeof|stack|super|switch|this|throw|trait|true|try|typeof|union|unsigned|using|volatile|while|xor)\b'
      scope: keyword.control.flux

    # Type modifiers
    - match: '\b(const|volatile|signed|unsigned|heap|stack|register)\b'
      scope: storage.modifier.flux

    # Special methods (dunder methods)
    - match: '\b__[a-z]+__\b'
      scope: entity.name.function.special.flux

    # Function definitions
    - match: '\b(def)\s+({{identifier}})'
      captures:
        1: keyword.control.flux
        2: entity.name.function.flux

    # Function calls
    - match: '{{identifier}}(?=\s*\()'
      scope: entity.name.function.call.flux

    # Variables and identifiers (catch-all, must be near the end)
    - match: '{{identifier}}'
      scope: variable.other.flux

    # Member access
    - match: '\.'
      scope: punctuation.accessor.dot.flux

    # Address-of operator
    - match: '@'
      scope: keyword.operator.address.flux

    # Pointer dereference
    - match: '\*(?=[a-zA-Z_])'
      scope: keyword.operator.dereference.flux

    # Numbers - Duotrigesimal
    - match: '\b0d[0-9A-V]+u?\b'
      scope: constant.numeric.duotrigesimal.flux

    # Numbers - Hex
    - match: '\b0x[0-9A-F]+u?\b'
      scope: constant.numeric.hex.flux

    # Numbers - Octal
    - match: '\b0o[0-7]+u?\b'
      scope: constant.numeric.octal.flux

    # Numbers - Binary
    - match: '\b0b[01]+u?\b'
      scope: constant.numeric.binary.flux

    # Numbers - Float
    - match: '\b\d+\.\d+([eE][+-]?\d+)?\b'
      scope: constant.numeric.float.flux

    # Numbers - Integer
    - match: '\b\d+u?\b'
      scope: constant.numeric.integer.flux

    # Operators - Custom operator definition
    - match: '\[([~!@#$%^&*\-+=|<>]+)\]'
      scope: keyword.operator.custom.flux

    # Operators - Custom operator usage (3+ character combinations that aren't standard)
    - match: '(>>>|<<<|<->|<<=|>>=|\^\^|~~|!=|<=|>=)'
      scope: keyword.operator.custom.flux

    # Operators - Comparison
    - match: '(==|!=|>=|<=|>|<)'
      scope: keyword.operator.comparison.flux

    # Operators - Logical
    - match: '(\&\&|\|\||!|and|or|not|xor)'
      scope: keyword.operator.logical.flux

    # Operators - Bitwise
    - match: '(\&|\||\^|~|<<|>>)'
      scope: keyword.operator.bitwise.flux

    # Operators - Arithmetic
    - match: '(\+\+|\-\-|\+|\-|\*\*|\*|/|%)'
      scope: keyword.operator.arithmetic.flux

    # Operators - Assignment
    - match: '(\+=|\-=|\*=|/=|%=|<<=|>>=|\&=|\|=|\^=|=)'
      scope: keyword.operator.assignment.flux

    # Range operator
    - match: '\.\.'
      scope: keyword.operator.range.flux

    # Arrow for return types
    - match: '->'
      scope: keyword.operator.arrow.flux

    # Brackets
    - match: '\{'
      scope: punctuation.section.block.begin.flux
    - match: '\}'
      scope: punctuation.section.block.end.flux
    - match: '\['
      scope: punctuation.section.brackets.begin.flux
    - match: '\]'
      scope: punctuation.section.brackets.end.flux
    - match: '\('
      scope: punctuation.section.parens.begin.flux
    - match: '\)'
      scope: punctuation.section.parens.end.flux

    # Punctuation
    - match: ';'
      scope: punctuation.terminator.flux
    - match: ','
      scope: punctuation.separator.flux
    - match: ':'
      scope: punctuation.separator.colon.flux

  # String contexts
  string_body:
    - meta_scope: string.quoted.double.flux
    - match: '"'
      scope: punctuation.definition.string.end.flux
      pop: true
    - match: '\\[\\"nrt0]'
      scope: constant.character.escape.flux

  i_string_body:
    - meta_scope: string.quoted.double.flux
    - match: '"'
      scope: punctuation.definition.string.end.flux
      set: i_string_statement_block
    - match: '\{'
      scope: punctuation.section.interpolation.begin.flux
      push: interpolation_scope
    - match: '\\[\\"nrt0]'
      scope: constant.character.escape.flux

  f_string_body:
    - meta_scope: string.quoted.double.flux
    - match: '"'
      scope: punctuation.definition.string.end.flux
      pop: true
    - match: '\{[^}]*\}'
      scope: meta.interpolation.flux

  i_string_statement_block:
    - match: ':'
      scope: punctuation.separator.colon.flux
      set: i_string_statements
    - match: '(?=\S)'
      pop: true

  i_string_statements:
    - match: '\{'
      scope: punctuation.section.block.begin.flux
      set: i_string_statements_inner
    - match: '(?=\S)'
      pop: true

  i_string_statements_inner:
    - include: main
    - match: '\}'
      scope: punctuation.section.block.end.flux
      pop: true

  char_body:
    - meta_scope: string.quoted.single.flux
    - match: "'"
      scope: punctuation.definition.string.end.flux
      pop: true
    - match: '\\[\\''nrt]'
      scope: constant.character.escape.flux
    - match: '.'
      scope: string.quoted.single.flux

  interpolation_scope:
    - match: '\}'
      scope: punctuation.section.interpolation.end.flux
      pop: true
    - include: main

  multiline_comment:
    - meta_scope: comment.block.flux
    - match: '///'
      scope: punctuation.definition.comment.end.flux
      pop: true