// Flux Language Grammar for Lark Parser
// Based on the Flux language specification

?start: program

program: (import_stmt | using_stmt | global_item)*

// Import and using statements
import_stmt: "import" STRING ";"
using_stmt: "using" using_list ";"
using_list: using_item ("," using_item)*
using_item: IDENTIFIER ("::" IDENTIFIER)*

// Global items
global_item: function_def
          | object_def
          | struct_def
          | namespace_def
          | macro_def
          | extern_block
          | compt_block

// Function definitions
function_def: ["volatile"] "def" IDENTIFIER template_params? "(" param_list? ")" "->" type_spec block_stmt
param_list: param ("," param)*
param: type_spec IDENTIFIER

// Template parameters
template_params: "<" template_param_list ">"
template_param_list: IDENTIFIER ("," IDENTIFIER)*

// Object definitions
object_def: "object" IDENTIFIER template_params? [":" inheritance_list] ["{" object_body "}"] ";"
inheritance_list: inheritance_item ("," inheritance_item)*
inheritance_item: ["virtual" "::"] IDENTIFIER template_params?
object_body: (access_spec | object_member)*
object_member: function_def
             | object_def
             | struct_def
             | variable_decl ";"
access_spec: ("public" | "private") "{" (object_member)* "}" ";"

// Struct definitions
struct_def: "struct" IDENTIFIER template_params? [":" inheritance_list] ["{" struct_body "}"] ";"
struct_body: (access_spec | struct_member)*
struct_member: variable_decl ";"
            | struct_def

// Namespace definitions
namespace_def: "namespace" IDENTIFIER "{" namespace_body "}" ";"
namespace_body: (function_def | object_def | struct_def | namespace_def)*

// Macro definitions
macro_def: "def" IDENTIFIER expr ";"

// External FFI
extern_block: "extern" "(" STRING ")" "{" extern_decl* "}" ";"
extern_decl: "def" IDENTIFIER "(" param_list? ")" "->" type_spec ";"

// Compile-time blocks
compt_block: "compt" "{" stmt* "}" ";"

// Type specifications
type_spec: data_type
         | basic_type
         | void_type  // <-- Add this
         | array_type
         | pointer_type
         | function_pointer_type
         | template_type

data_type: ["signed" | "unsigned"] "data" "{" data_spec "}"
data_spec: NUMBER
        | NUMBER ":" NUMBER
        | NUMBER ":" NUMBER ":" NUMBER
        | NUMBER "::" NUMBER

basic_type: "bool" | "int" | "float" | "char"  // Remove "void"
void_type: "void"  // Explicit rule for void-as-type
literal: NUMBER | FLOAT | STRING | CHAR | BOOLEAN | "void"
array_type: type_spec "[" [expr] "]"
pointer_type: type_spec "*"
function_pointer_type: type_spec "(" "*" IDENTIFIER ")" "(" param_list? ")" "->" type_spec
template_type: IDENTIFIER template_args?
template_args: "<" template_arg_list ">"
template_arg_list: type_spec ("," type_spec)*

// Variable declarations
variable_decl: type_spec variable_list
variable_list: variable_item ("," variable_item)*
variable_item: IDENTIFIER ["=" expr]

// Statements
stmt: block_stmt
    | expr_stmt
    | if_stmt
    | for_stmt
    | while_stmt
    | do_while_stmt
    | switch_stmt
    | try_catch_stmt
    | return_stmt
    | break_stmt
    | continue_stmt
    | throw_stmt
    | assert_stmt
    | asm_stmt
    | variable_decl ";"

block_stmt: "{" stmt* "}" ";"

expr_stmt: expr ";"

if_stmt: "if" "(" expr ")" stmt ("else" "if" "(" expr ")" stmt)* ["else" stmt] ";"

for_stmt: "for" "(" (for_init | for_range) ")" stmt ";"
for_init: [variable_decl | expr] ";" [expr] ";" [expr]
for_range: IDENTIFIER ["," IDENTIFIER] "in" expr

while_stmt: "while" "(" expr ")" stmt ";"

do_while_stmt: "do" stmt "while" "(" expr ")" ";"

switch_stmt: "switch" "(" expr ")" "{" case_list "}" ";"
case_list: (case_stmt | default_stmt)*
case_stmt: "case" "(" expr ")" stmt
default_stmt: "default" stmt ";"

try_catch_stmt: "try" stmt catch_list ";"
catch_list: catch_clause+
catch_clause: "catch" "(" type_spec IDENTIFIER ")" stmt

return_stmt: "return" [expr] ";"
break_stmt: "break" ";"
continue_stmt: "continue" ";"
throw_stmt: "throw" "(" expr ")" ";"
assert_stmt: "assert" "(" expr ["," expr] ")" ";"

asm_stmt: "asm" "{" asm_content "}" ";"
asm_content: /[^}]*/

// Expressions (with precedence)
?expr: conditional_expr

?conditional_expr: logical_or_expr ["?" expr ":" conditional_expr]

?logical_or_expr: logical_and_expr (("or" | "||" | "!|") logical_and_expr)*

?logical_and_expr: bitwise_or_expr (("and" | "&&" | "!&") bitwise_or_expr)*

?bitwise_or_expr: bitwise_xor_expr (("|" | "`|" | "`!|") bitwise_xor_expr)*

?bitwise_xor_expr: bitwise_and_expr (("^^" | "xor" | "`^^" | "`^!|") bitwise_and_expr)*

?bitwise_and_expr: identity_expr (("&" | "`&" | "`!&" | "`^&" | "`^!&") identity_expr)*

?identity_expr: equality_expr (("is" | "not") equality_expr)*

?equality_expr: relational_expr (("==" | "!=") relational_expr)*

?relational_expr: range_expr
                | range_expr ("<" | "<=" | ">" | ">=" | "in") range_expr

?range_expr: shift_expr (".." shift_expr)*

?shift_expr: additive_expr (("<<" | ">>") additive_expr)*

?additive_expr: multiplicative_expr (("+" | "-") multiplicative_expr)*

?multiplicative_expr: exponential_expr (("*" | "/" | "%") exponential_expr)*

?exponential_expr: cast_expr ("^" exponential_expr)?

?cast_expr: "(" type_spec ")" cast_expr  // Explicit cast
          | unary_expr                   // Otherwise, treat as unary

?unary_expr: postfix_expr
           | "++" unary_expr
           | "--" unary_expr
           | ("+" | "-" | "!" | "~" | "@" | "*" | "not") unary_expr
           | ("sizeof" | "typeof" | "alignof") "(" type_spec ")"

?postfix_expr: primary_expr postfix_suffix*

postfix_suffix: "++"
             | "--"
             | "[" expr "]"
             | "." IDENTIFIER
             | "::" IDENTIFIER
             | "(" arg_list? ")"
             | template_args

arg_list: expr ("," expr)*

?primary_expr: IDENTIFIER
            | literal
            | "(" expr ")"
            | "this"
            | "super"
            | array_literal
            | object_init
            | function_call_chain
            | i_string
            | f_string
            | array_comprehension
            | destructuring_assignment

array_literal: "[" [expr_list] "]"
expr_list: expr ("," expr)*

object_init: IDENTIFIER template_args? "(" arg_list? ")"

function_call_chain: expr "<-" expr

// String interpolation
i_string: "i" STRING ":" "{" expr_list "}" ";"
f_string: "f" STRING ";"

// Array comprehension
array_comprehension: "[" expr "for" "(" for_range ")" ["if" "(" expr ")"] "]"

// Destructuring assignment
destructuring_assignment: "auto" "{" identifier_list "}" "=" expr "{" identifier_list "}"
identifier_list: IDENTIFIER ("," IDENTIFIER)*

// Assignment expressions
assignment_expr: conditional_expr
              | unary_expr assignment_op assignment_expr

assignment_op: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "^^=" | "<<=" | ">>=" | "`&=" | "`!&=" | "`|=" | "`!|=" | "`^=" | "`!="

// Terminals
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /0x[0-9a-fA-F]+/ | /0b[01]+/ | /\d+/
FLOAT: /\d+\.\d+/
STRING: /"[^"]*"/
CHAR: /'[^']'/
BOOLEAN: "true" | "false"

// Comments
COMMENT: "//" /[^\n]*/
MULTILINE_COMMENT: "/*" /(.|\n)*?/ "*/"

// Whitespace
%import common.WS
%ignore WS
%ignore COMMENT
%ignore MULTILINE_COMMENT