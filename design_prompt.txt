Flux language interpreter design prompt.

Follow all instructions exactly. Do not deviate from instructions.
Do not add types not defined in the keyword list.
The keyword list only has the types `int`, `float`, `char`, `signed` or `unsigned` `data`, `volatile`, pointer, and `const` types.
Do not add types like `i32`, `ufloat`, `byte`, `bit`, as these are user-defined types built from the `data` keyword.
Only `int`, `float`, `char`, and `data` are valid built-in primitive types.

All statements, compound-statements, and code blocks end with semicolons. This eliminates semicolon position ambiguity.

Examples of compound statements:
`if (expr) {...} else (expr) {...};`
`do {...} while (expr);`

Templates are written as they're named.

All components are to be designed simply, minimalistically, and imperatively; recursive design is to be avoided at all costs.

The components of this interpreter are:

The Lexer               - flexer.py
The AST                 - fast.py
The Parser              - fparser.py
The Type Checker        - ftyper.py
LLVM                    - fllvm.py

All programs should be written so they may take a file name as an argument from the command line.

We will combine this with LLVM to be capable of compiling Flux.
Once Flux can be compiled with LLVM, the native compiler will be written in Flux and ran on itself.

The lexer produces a token list for the parser to consume.
The parser produces the AST.
The VM type checks, produces byte-code for itself from the AST, and then executes.

All components should build off of the one before it in the chain of processing, such as:
The Parser builds off of the AST, the Lexer, and the Grammar Rules.

If it's not a keyword in the lexer list, it doesn't exist in Flux. Do not create new keywords for Flux during the design process.
Use only features explicitly documented in the language specification.

Ensure all explicitly documented features are implemented; do not omit, simplify, or stub code in the name of brevity.
This is a real project and you should treat it as such by making sure all components are feature complete.

If at any point you think you need to create a work-around, do not do so; instead notify the user that a required component is missing functionality.