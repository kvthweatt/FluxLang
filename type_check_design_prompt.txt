Type Checker design prompt for the Flux Programming Language:

The type checker should be aware of how the `data` keyword works.
It should follow the rules of type definition and variable declaration.
An identifier created by a `data` declaration is always a type unless it is assigned a value.

`data{8} byte;`        // byte in this case is a type, meaning we can do `byte myByte = 0x41;`
`data{8} byte = 0x97;` // byte is this case is a variable, we cannot do `byte x;` as this will be a type error.

typeof() reveals the primitive type of any type.
Example, if we have a very complicated type and check it, you'll see what it actually is:
```
unsigned data {32} myType;
myType xA;
xA xB;              // xA makes new type xB
xB xC;              // xB makes new type xC
xC xD;              // xC makes new type xD
typeof(xD);         // `unsigned data{32:32}`
alignof(xD);        // 32
sizeof(xD);         // 32
```

Because of the nature of function definitions and the return type being an explicit cast of any return given, return statements should not yield type check errors.

Example:
```
def foo() -> int
{
	return 1.0;         // As if `return (int)1.0;` was written. No type check error should happen here.
}

def bar() -> int
{
	float x = 1.0;
	return x;           // As if `return (int)x;` was written. No type check error should happen here.
}
```