Flux is a mix of C++, Zig, and Python, and has a slightly more strict syntax than C++ or Zig.

Flux gets its name from flux or solder paste used to clean in preparation for soldering,
ie to perform electrical engineering. Programming in Flux is clearly good for your computer.

Flux has a manual memory model. Memory management is up to the programmer.

A Flux program must have a main() function, and must be defined in global scope.

**Function definition:**
```
def name (parameters) -> return_type
{
	return return_value;                      // A `return` statement must be found somewhere within a function body.
};

// Example function
def myAdd(int x, int y) -> int
{
	return x + y;
};

// Overloading
def myAdd(float x, float y) -> float
{
	return x + y;
}
```

**Namespaces:**
Definition: `namespace myNamespace {};`
Scope access: `myNamespace::myMember;`

Namespace example:
```
namespace std
{
	object myObj1
	{
		def __init() -> this
		{
			return this;
		};

		def __exit() -> void
		{
			return void;
		};
	};
};

namespace std                         // namespace std now has myObj1 and myObj2
{
	object myObj2
	{
		def __init() -> this
		{
			return this;
		};

		def __exit() -> void
		{
			return void;
		};
	};
};
```

Namespaces **MUST** be in global scope.
Duplicate namespace definitions do not redefine the namespace, the members
of both combine as if they were one namespace. This is so the standard
library or any library can have a core namespace across multiple files.
Namespaces are the only container that have this functionality.

**Objects:**
Prototype / forward declaration: `object myObj;`
Definition: `object myObj {};`
Instance: `myObj newObj();`
Member access: `newObj.x`

Magic Methods:
```
// `this` never needs to be a parameter as it is always local to its object.
// Meaning, you do not need to do `def __init(this, ...) -> this` which is the Python equivalent to `def __init__(self, ...):`, the 'self' or 'this' in Flux
// does not need to be a parameter like in Python.
__init()       -> this               Example: thisObj newObj(); // Constructor
__exit()       -> void               Example: newObj.__exit();  // Destructor
__expr()       -> // expression form Example: print(someObj);          // Result: expression evaluated and printed
__eq()         -> // user-defined =  Example: someObj newObj = oldObj; // Result: user-defined gets assigned to newObj
__ee()         -> // user-defined ==
__ne()         -> // user-defined !=
__lte()        -> // user-defined <=
__gte()        -> // user-defined >=
__lt()         -> // user-defined <
__gt()         -> // user-defined >
__add()        -> // user-defined +
__sub()        -> // user-defined -
__inc()        -> // user-defined ++
__dec()        -> // user-defined --
__mul()        -> // user-defined *
__div()        -> // user-defined /
__iadd()       -> // user-defined +=
__isub()       -> // user-defined -=
__imul()       -> // user-defined *=
__idiv()       -> // user-defined /=
__mod()        -> // user-defined %
__pow()        -> // user-defined ^
__imod()       -> // user-defined %=
__ipow()       -> // user-defined ^=
__ls()         -> // user-defined (left-shift)
__rs()         -> // user-defined (right-shift)
__and()        -> // user-defined && / and
__or()         -> // user-defined || / or
__xor()        -> // user-defined ^^ / xor
__nand()       -> // user-defined !&
__nor()        -> // user-defined !|
__xand()       -> // user-defined ^&
__xnor()       -> // user-defined ^!|
__xnand()      -> // user-defined ^!&
// Operations starting with a b with operators starting with a ` are binary operators
__band()       -> // user-defined `&
__bor()        -> // user-defined `|
__bxor()       -> // user-defined `^|
__bnand()      -> // user-defined `!&
__bnor()       -> // user-defined `!|
__bxand()      -> // user-defined `^&
__bxnor()      -> // user-defined `^!|
__bxnand()     -> // user-defined `^!&
__andeq()      -> // user-defined &=
__oreq()       -> // user-defined |=
__xoreq()      -> // user-defined ^^=
__nandeq()     -> // user-defined !&=
__noreq()      -> // user-defined !|=
__xandeq()     -> // user-defined ^&=
__xnoreq()     -> // user-defined ^!|=
__xnandeq()    -> // user-defined ^!&=
__bandeq()     -> // user-defined `&=
__boreq()      -> // user-defined `|=
__bxoreq()     -> // user-defined `^|=
__bnandeq()    -> // user-defined `!&=
__bnoreq()     -> // user-defined `!|=
__bxandeq()    -> // user-defined `^&=
__bxnoreq()    -> // user-defined `^!|=
__bxnandeq()   -> // user-defined `^!&=
__cast()       -> // Define cast behavior
```

**Example of defining cast behavior:**
// Casts are C-like, and have the same notation: (type)variable
```
signed data{32} i32;

float x = 3.14;                  // 01000000010010001111010111000010b
i32 y = (i32)x;                  // 01000000010010001111010111000010b   but now treated as an integer  1078523330 == 0x4048F5C2
```
Example usage:
```
import "standard.fx";

using std::io, std::types;

object myObj
{
	int a, b;
	def __init(int x, int y) -> this
	{
		this.a = x;                           // __init is a special method, and is the constructor function
		this.b = y;                           // you must always specify "this" as the -> return type
		return this;
	};

	def __exit() -> void
	{
		return void;                               // __exit is a special method, and is the destructor function
	};

	def __add(this other) -> this
	{
		new_a = this.a + other.a;
		new_b = this.b + other.b;             // this in this context is functionally equivalent to `myObj`
		return this(new_a,new_b);             // but you cannot write `myObj` here unless it is forward-declared.
	};

	def func() -> void
	{
		return void;
	};
};

myObj testObject(3,5);
```

Inheritance:
```
object XYZ;   // Forward declaration

object myObj
{
	def __init() -> this
	{
		return this;
	};

	def __exit() -> void
	{
		return void;
	};
};

object anotherObj : myObj, XYZ             // Can perform multiple inheritance
{
	def __init() -> this
	{
		this newObj(10,2);
		return this;
	};

	def __exit() -> void
	{
		return void;
	};
};

object obj1 : anotherObj, myObj
{
	// __init() is not defined in this object
	// We inherit the __init() from anotherObj (first in the inheritance list)
	// If we want to inherit __init() from myObj, we put myObj first in the inheritance list.

	object obj2
	{
		super z1();        // Create instance of obj1
		super.myObj z2();  // Fails, makes no sense, obj1 inherited properties of myObj
		myObj z2();        // Succeeds, myObj is global
	};
};
```

Objects cannot be defined inside of a function, they must be within a namespace, another object, or global scope.
`__init` is always called on object instantiation.
`__exit` is always called on object destruction, or called manually to destroy the object.

Structs can contain instances of objects.
Structs cannot contain functions, templates, or anonymous blocks.

**struct example:**
```
struct myStruct
{
	myObject newObj1, newObj2;
};

struct newStruct
{
	myStruct xStruct;              // structs can contain structs
}
```


If a function's return type is void nothing will be returned, regardless if your return statement provides something.
The return type specifier acts as a cast, guaranteeing the type you return is the intended type.
In essence, `-> int` acts in the place of int in the context of `return (int)value;`
Say for example the return statement was `return x + y;`, the equivalent cast would be `return (int)(x + y);`
and not `return (int)x + y;` as that only casts the `x` and not the value of `x + y`.
This is why if a function's return type is void, nothing is returned.

You can also use in-line assembly directly:

```
asm
{
mov eax, 1
mov ebx, 0
int 0x80
};
```

Python uses f-strings, C++ uses a complicated format, Zig syntax is overly verbose.
Flux uses "interpolated" strings and Python f-strings but without formatting, and tries to fix Zig's syntax a bit.
The syntax in Flux would be: `i"{}{}{}":{x;y;z;};`
The brackets are replaced with the results of the statements in order respective
to the statements' position in the statement array.

**i-string Example:**
```
import "standard.fx";

using std::io;

unsigned data{8}[] string;

def bar() -> string { return "World"; };    // We get the basic string type from the types module
print(i"Hello {} {}" : // whitespace is ignored
              {
              	bar() + "!";
                "test";
              }                             // Whitespace is ignored, this is just for positioning
     );
x = i"Bar {}":{bar()};                      // "Bar World!"

string a = "Hello", b = "World!";
string y = f"{a} {b}";                      // "Hello World!"
```

This allows you to write clean interpolated strings without strange formatting.
Every code block must be ended with a semicolon. The only exception is within the i-string "quoted {} injected {} text"


Example 2:
```
import "standard.fx";

using std::io;

unsigned data{8}[] string;

def concat(string a, string b) -> string
{
    return a+b;           // array concatination is native so we really don't need this function
};

def main() -> int
{
    string h = "Hello ";
    string w = "World";   // strings are arrays of data{8} (bytes), so we can do `w[3] == 'l'`
    string x = "of ";
    string y = "Coding";
    print(i"{} {}":{concat(h,w);concat(x,y);});
    return 0;
};
```
Result: Hello World of Coding


**Pointers:**
```
string a = "Test";
string* pa = @a;
*pa += "ing!";
print(a);
// Result: "Testing!"


// Pointers to variables:
int idata = 0;
int *p_idata = @idata;

*p_idata += 3;
print(idata);  // 3


// Pointers to functions:
def add(int x, int y) -> int { return x + y; }
def sub(int x, int y) -> int { return x - y; }

// Function pointer declarations
int (*p_add)(int,int) = @add;
int (*p_sub)(int,int) = @sub;

// Must dereference to call
print((*p_add)(0,3)); // 3
print((*p_sub)(5,2)); // 3

// Array of function pointers
int (*func_list[])(int,int) = {@add, @sub};
(*func_list[0])(1,1); // 2

// Pointers to objects, structs, arrays:
object    myObj {};                 // Definition
object* p_myObj = @myObj;           // Pointer

struct    myStruct {};              // Definition
struct* p_myStruct = @myStruct;     // Pointer

int[]   i_array;                    // Definition
int[]* pi_array = @i_array;         // Pointer


// Pointer Arithmetic:
import "standard.fx";

using std::io, std::types;

def main() -> int
{
    int[] arr = [10, 20, 30, 40, 50];
    int[]* ptr = @arr;                         // ptr points to the first element of arr
    
    print(f"Value at ptr: {*ptr}");            // Output: 10
    
    ptr++;    // Increment ptr to point to the next element
    print(f"Value at ptr: {*ptr}");            // Output: 20
    
    ptr += 2; // Increment ptr by 2 positions
    print(f"Value at ptr: {*ptr}");            // Output: 40
    
    int *ptr2 = @arr[4]; // ptr2 points to the last element of arr
    print(f"Elements between ptr and ptr2: {ptr2 - ptr}"); // Output: 1
    
    return 0;
};
```


**Recursive function:**
```
def rsub(int x, int y) -> int
{
	if (x == 0 || y == 0) { return 0; };

	rsub(--x,--y);
};
```


**If/Else If/Else:**
```
if (condition1)
{
	doThis();
}
else if (condition2)
{
	doThat();
}
else
{
	doThings();
};


**Import:**
// The way import works is C-like, where its as if the source code of the file you're importing
// takes the place of the import statement.
//
// However that does not mean you will have access to namespaces. You must "use" them with `using`
// This is to prevent binary bloat after compilation
```
import "standard.fx";
using std::io, std::types;          // Only use `io` and `types` namespaces from the `std` namespace.
```


**The `data` keyword:**
//
// Data types use big-endian byte order by default.
// Use bit manipulation operators to reorder as needed.
//
// When declaring an identifier with `data`, if it is not initialized it is treated as a new type.
// `unsigned data{32} ui32;` is the C++ equivalent of `typedef unsigned int uint;`
// However, if I assign anything TO ui32, then ui32 becomes a variable of type `unsigned data{32}`
// Meaning if I wanted to make a custom boolean type called `boolean` I would do:
// `unsigned data{1} boolean; boolean myTrue = 1, myFalse = 0;`
// In this context, boolean is a type. However if I did the following:
// `unsigned data{1} boolean = 0;` Then boolean is a variable with type `unsigned data{1}`
//
// This allows the creation of primitive, non-OOP types that can construct other types.
//
// For example, I can just keep inventing types until I assign a value like so:
//
// `unsigned data{16} dbyte;`
// `dbyte xbyte;`
// `xbyte ybyte = 0xFF;`  // ybyte is now a variable identifier, not a type identifier like xbyte
//
// For example, a non-OOP string is defined as:
// `unsigned data{8}[] string;` - An array of unsigned bytes
//
// The raw syntax of a data declaration is:
// `[signed|unsigned] data{bit-width:alignment} newtype;`
// Therefore `unsigned data{13:16} mytype;` makes an unsigned 13-bit wide and 16 bit aligned type called mytype
// If alignment isn't specified, it is packed tightly in memory.
```
import "standard.fx";

unsigned data{8} byte;
byte[] string;

byte someByte = 0x41;                         // "A" but in binary
string somestring = (string)((char)someByte); // "A"
// Back to data
somestring = (data)somestring;                // 01000001b
string anotherstring = "B";                   // 01000010b

somestring<<;                                 // 10000100b  // Bit-shift left  (binary doubling)
somestring>>;                                 // 01000010b  // Bit-shift right (binary halving)
somestring<<2;                                // 00001000b  // Information lost
somestring>>2;                                // 00000010b

newstring = somestring xor anotherstring;     // 01000000b  // XOR two or more values

// This 0's out all the data and re-casts back to data from void.
// an unspecified bit-width will adopt the width of the casted type, in this case 8 bits.
data v = (void)somestring;                    // 00000000b
sizeof(v);                                    // 8

data{sizeof(somestring)} nulled = (void)somestring;

Casting objects or structs to `data` results in a new data variable with bit width equal to the size of the object/struct's length.
If the object took up 1KB of memory, the resulting `data` variable will be 1024 bits wide.
You cannot do the reverse with objects or structs unless **ALL** of their member types are explicitly aligned, otherwise you risk corrupting your resulting object/struct.
```

Casting anything to `void` is the functional equivalent of freeing the memory occupied by that thing.
If the width of the data type is 512 bits, that many bits will be freed.
This is dangerous on purpose, the compiler will throw very verbose warnings at you.
It is expected you know what you're doing.

Data is a variable bit width, primitive binary data type. Anything can cast to it,
and it can cast to any literal Flux type like char, int, or float.
It is intended to allow Flux programmers to build complex flexible custom types to fit their needs.


**types.fx module:**
// imported by standard.fx
```
// The standard types found in Flux that are not included keywords
// This is an excerpt and not a complete list of all types defined in the standard library of types
signed   data{32}  i32;
unsigned data{32} ui32;
signed   data{64}  i64;
unsigned data{64} ui64;
```


**alignof, sizeof, typeof:**
// typeof() operates both at runtime
// A Flux binary has a symbol map of types to accomplish this without a large amount of overhead.
```
unsigned data{8:8}[] string;
signed data{13:16} strange;

sizeof(string);   // 8
alignof(string);  // 8
typeof(string);   // unsigned data{8:8}*

sizeof(strange);  // 13
alignof(strange); // 16
typeof(strange);  // signed data{13:16}
```


**Structs:**
```
// structs are packed and have no padding naturally
// there is no way to change this.
// You add your own padding data structures manually.
// Members of structs are aligned and tightly packed according to their width unless the types have specific alignment
struct myStruct1
{
    unsigned data {8} status;
    unsigned data {32} address;
};  // This struct is exactly 40 bits wide

struct myStruct2
{
    unsigned data {8:16} status;
    unsigned data {32:8} address;
};  // @address = @status + 16    // This struct is exactly 48 bits wide
```


**Example of bare-metal register access:**
```
// Define a struct for a hardware register map
struct GPIORegisters {
    unsigned data {32} control;
    unsigned data {32} status;
    unsigned data {64} buffer;
};

// Map to a fixed hardware address
volatile const GPIORegisters* GPIO = @0x40000000;

def main() -> int {
    GPIO.control = 0x1;  // Write to control register (aligned access)
    asm { cli };         // Disable interrupts (assembly inline)
    return 0;
};
```


**The void keyword:**
void is equivalent to Python's None as well as C++'s void and can be used in both contexts such as:
```
if (x is void) {...code...};    // If it's nothing, do something
void x;
if (x is !void) {...code...};   // If it's not nothing, do something
```


**Templates:**
```
// Function templates
template <T> myMax(T x, T y) -> T
{
    return (x > y) ? x : y;
};
// Usage
int k = myMax<int>(5,10);             // 10

template <V,K,R> someFunc(V x, K y) -> R
{
	return (R)x*y;
};
// Usage
char n = someFunc<int,int,char>(5,13);  // 65 == 'A'

// Pointer to template function:
template* tp_myMax = @myMax;
// Usage
tp_myMax<int>(12,12);                   // 144

// Volatile templates
volatile template<T> myMax(T x, T y) {};
```

Template shadowing is allowed and there will be no warning for it. It is assumed you know
what you are doing. Any inner T refers to the nearest outer T, if none exists and is not
used in code somewhere, then and only then is it a compiler error because T won't exist.
You do not need to use `super.T;`.


**Arrays:**
```
import "standard.fx" as std;
using std::io, std::types;

int[] ia_myArray = [3, 92, 14, 30, 6, 5, 11, 400];

// int undefined_behavior = ia_myArray[10];          // Length is only 8, accessing index 11

int[] ia_mySorted = [];
int tmp, lowest;

def len(int[] array) -> int
{
	return sizeof(array) / sizeof(int);
}
```

**Array Comprehension:**
```
// Basic comprehension
int[] squares = [x ^ 2 for (x in 1..10)];

// With condition
int[] evens = [x for (x in 1..20) if (x % 2 == 0)];

// Multi-dimensional
int[][] matrix = [i * j for (j in 10..50)][i * j for (j in 100..500)];

// With type conversion
float[] floats = [(float)x for (x in int_array)];
```

**Loops:**
// Flux supports 2 styles of for loops, it uses Python style and C++ style
```
for (x in y)
{
	// ... code ...
};

for (int c = 0; c < 10; c++)
{
	// ... code ...
};

do
{
	// ... code ..
}
while (condition);

while (condition)
{
	// ... code ...
};
```

**Destructuring:**
```
struct Point { int x; int y; };

Point myPoint = {x = 10, y = 20};

auto {t, m} = myPoint{x,y};     // int   t=10,   int    m=20
```

**Casting:**
```
//(type)identifier

int x = 65;
char y = (char)x;   // "A"
```

**Error handling with try/throw/catch:**
```
unsigned data{8}[] string;  // Basic string implementation with no functionality (non-OOP string)

object ERR
{
	string e;

	def __init(string e) -> this
	{
		this.e = e;
		return this;
	};

	def __expr() -> string
	{
		return this.e;
	};

	def __exit() -> void
	{
		return void;
	};
};

def myErr(int e) -> void
{
	switch (e)
	{
		case (0)
		{
			ERR myE("Custom error from object myE");
			throw(myE);
		};
		default
		{
			throw("Default error from function myErr()");
		};
	};
};

def thisFails() -> bool
{
	return false;
};

def main() -> int
{
	string error = "";
	try
	{
		try
		{
			if(thisFails())
			{
				myErr(0);
			}
		}
		catch (string x)  // Only catch a primitive string (unsigned data{8}[]) thrown
		{
		};
		catch (auto x)    // Receive myE thrown from function myErr(), automatically typed e as ERR
		{
			string err = x.e;    // "Custom error from object myE"
			throw("Thrown from nested try-catch block.");
		};
	}
	catch (string x)
	{
		error = x;  // "Thrown from nested try-catch block."
	};

	return 0;
};
```

Keyword list:
```
alignof, and, asm, assert, auto, break, bool, case, catch, const, continue, data, def
default, do, else, enum, false, float, for, if, import, in, int, is, namespace
not, object, or, return, signed, sizeof, struct, super, switch, template, this,
throw, true, try, typeof, unsigned, using, void, volatile, while, xor
```


Literal types:
int `5`, float `3.14`, char `"B"` == `66` - `65` == `'A'`

================================================================================
                        FLUX OPERATOR PRECEDENCE TABLE
                              (Highest to Lowest)
================================================================================

Level | Operators                                                        | Assoc | Description
------|------------------------------------------------------------------|-------|------------------
  1   | () [] . ::                                                       | Left  | Primary expressions
  2   | ++ -- (postfix)                                                  | Left  | Postfix inc/dec
  3   | ++ -- (prefix) + - ! ~ @ * not sizeof typeof                     | Right | Unary operators
  4   | (type)                                                           | Right | Type casting
  5   | ^                                                                | Right | Exponentiation
  6   | * / %                                                            | Left  | Multiplicative
  7   | + -                                                              | Left  | Additive
  8   | << >>                                                            | Left  | Bit shift
  9   | < <= > >= in                                                     | Left  | Relational
 10   | == !=                                                            | Left  | Equality
 11   | is not as                                                        | Left  | Identity
 12   | & `&& `!& `^& `^!&                                               | Left  | Bitwise AND variants
 13   | ^^ xor `^^ `^!|                                                  | Left  | Bitwise XOR variants
 14   | | `| `!|                                                         | Left  | Bitwise OR variants
 15   | and && !&                                                        | Left  | Logical AND/NAND
 16   | or || !|                                                         | Left  | Logical OR/NOR
 17   | ?:                                                               | Right | Conditional
 18   | = += -= *= /= %= ^= &= |= ^^= <<= >>= `&&= `!&= `|= `!|= `^= `!= | Right | Assignment
 19   | ,                                                                | Left  | Comma

================================================================================

## Operator Details

### Bitwise Operators (` prefix)
- `&& - Bitwise AND
- `!& - Bitwise NAND  
- `| - Bitwise OR
- `!| - Bitwise NOR
- `^^ - Bitwise XOR
- `^!| - Bitwise XNOR
- `^& - Bitwise XAND
- `^!& - Bitwise XNAND

### Logical Operators
- && / and - Logical AND
- !& - Logical NAND
- || / or - Logical OR  
- !| - Logical NOR
- ^^ / xor - Logical XOR
- ! / not - Logical NOT

### Assignment Operators
- = - Basic assignment
- += -= *= /= %= ^= - Arithmetic assignment
- <<= >>= - Shift assignment
- `&&= `!&= `|= `!|= `^= `!= - Bitwise assignment

================================================================================