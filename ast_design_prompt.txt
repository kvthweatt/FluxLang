AST design prompt for the Flux Programming Language:

The AST should support all Flux language constructs.

The AST should be designed with the Type Checker in mind allowing the Type Checker to add type information to the AST afterwards.


# AST Design Prompt for the Flux Programming Language

## Core Requirements

The AST should support all Flux language constructs and be designed with the entire compilation pipeline in mind, particularly the Type Checker, Code Generator, and optimization passes.

## Fundamental Design Principles

### 1. Type Information Integration
- **Mutable Type Fields**: Each AST node should have mutable fields for type information that the Type Checker can populate during semantic analysis
- **Type Resolution**: Support for both resolved and unresolved types during different compilation phases
- **Generic Type Support**: Handle template types, type parameters, and template instantiation
- **Custom Data Types**: Support Flux's `data{width:alignment}` type system with bit-width and alignment information

### 2. Source Location Tracking
- **Complete Coverage**: Every AST node must track its source location (file, line, column, span)
- **Error Reporting**: Enable precise error messages and IDE integration
- **Debugging Support**: Support for generating debug information

### 3. Symbol Table Integration
- **Symbol References**: Nodes should support linking to symbol table entries
- **Scope Awareness**: Track lexical scoping for variables, functions, types, and namespaces
- **Forward Declarations**: Handle forward references and circular dependencies

## Required AST Node Categories

### 1. Program Structure
- **Module/File**: Root node representing a complete Flux source file
- **Import Declarations**: Handle `import "file.fx"` with alias support
- **Using Declarations**: Support `using namespace::member` syntax
- **Namespace Definitions**: Nested namespaces with member declarations

### 2. Type System Nodes
- **Primitive Types**: `int`, `float`, `char`, `bool`, `void`
- **Custom Data Types**: `data{width:alignment}` with compile-time evaluation
- **Pointer Types**: Support for pointer declarations and dereferencing
- **Array Types**: Both fixed-size and dynamic arrays
- **Template Types**: Generic type parameters and instantiated template types
- **Function Types**: Function signatures as first-class types

### 3. Declaration Nodes
- **Variable Declarations**: Local variables, global variables, parameters
- **Function Declarations**: Regular functions, template functions, operator overloads
- **Object Definitions**: Classes with inheritance, magic methods, member variables
- **Struct Definitions**: POD types with member layout
- **Template Declarations**: Template parameters, constraints, specializations
- **Enum Definitions**: If added to language later

### 4. Statement Nodes
- **Expression Statements**: Standalone expressions
- **Block Statements**: Compound statements with local scope
- **Control Flow**: `if/else`, `while`, `do-while`, `for` (both C-style and range-based)
- **Jump Statements**: `return`, `break`, `continue`, `throw`
- **Try-Catch-Throw**: Error handling with exception propagation
- **Switch Statements**: Pattern matching with fall-through control
- **Assembly Blocks**: Inline assembly with register constraints

### 5. Expression Nodes
- **Literals**: Integer, float, character, string, boolean, interpolated strings
- **Identifiers**: Variable references, function names, type names
- **Binary Operations**: All operators with proper precedence and associativity
- **Unary Operations**: Prefix and postfix operators, address-of, dereference
- **Call Expressions**: Function calls, method calls, template instantiation
- **Member Access**: Dot notation, scope resolution (`::`)
- **Array Indexing**: Subscript operations
- **Cast Operations**: Explicit type conversions
- **Template Instantiation**: Generic function/type specialization
- **Ternary Conditional**: `condition ? true_expr : false_expr`

### 6. Special Flux Features
- **Magic Methods**: `__init`, `__exit`, `__add`, etc. with special semantics
- **Operator Overloading**: Custom operator definitions for user types
- **String Interpolation**: `i"text {expression}"` with embedded expressions
- **Memory Management**: Manual allocation/deallocation expressions
- **Bitwise Operations**: Special syntax for `&`, `|`, `^^`, `!&`, etc.
- **Multiple Inheritance**: Object inheritance chains with virtual dispatch

## Advanced Design Considerations

### 1. Visitor Pattern Support
- **Double Dispatch**: Support for visitor pattern traversal
- **Mutable Visitors**: Allow AST modification during traversal
- **Multiple Visitor Types**: Different visitors for different compilation phases

### 2. Immutability vs Mutability
- **Structural Immutability**: AST structure should be immutable after parsing
- **Annotation Mutability**: Type information, symbol references, and optimization data should be mutable
- **Copy-on-Write**: Efficient cloning for template instantiation

### 3. Memory Management
- **Parent-Child Relationships**: Clear ownership hierarchy
- **Cyclic Reference Handling**: Manage references between symbol tables and AST nodes
- **Resource Cleanup**: Proper cleanup for dynamically allocated nodes

### 4. Template System Integration
- **Template AST Nodes**: Separate representation for template definitions vs instantiations
- **Type Parameter Substitution**: Mechanism for replacing type parameters with concrete types
- **Template Specialization**: Support for explicit template specializations
- **SFINAE Support**: Substitution Failure Is Not An Error for template overload resolution

### 5. Error Recovery and Partial ASTs
- **Error Nodes**: Special nodes to represent parsing errors while maintaining AST structure
- **Partial Compilation**: Support for type checking and analysis even with syntax errors
- **Error Propagation**: Track error states through the AST hierarchy

## Integration Requirements

### 1. Parser Integration
- **Bottom-Up Construction**: Support parser's bottom-up AST building
- **Error Recovery**: Graceful handling of syntax errors
- **Token Information**: Preserve original token information for IDE support

### 2. Type Checker Integration
- **Type Annotation**: Fields for storing resolved type information
- **Constraint Tracking**: Support for template constraints and type requirements
- **Inference Support**: Enable type inference algorithms
- **Error Collection**: Accumulate type errors without stopping analysis

### 3. Code Generator Integration
- **IR Generation**: Support for generating intermediate representation
- **Optimization Hints**: Annotations for optimization passes
- **Debug Information**: Maintain source mapping for debugging

### 4. IDE and Tooling Support
- **Incremental Parsing**: Support for partial AST updates
- **Semantic Highlighting**: Provide information for syntax highlighting
- **Auto-completion**: Enable symbol lookup and suggestion generation
- **Refactoring**: Support for safe AST transformations

## Specific Flux Language Considerations

### 1. Operator Precedence
Implement the complete operator precedence table from the language specification:
- 19 levels of precedence
- Special handling for bitwise operators with ` prefix
- Proper associativity rules

### 2. Magic Method Handling
- **Constructor/Destructor**: Special semantics for `__init` and `__exit`
- **Operator Overloads**: Map operators to magic method calls
- **Expression Forms**: `__expr` for string conversion
- **Assignment Overloads**: `__eq` vs `__ee` distinction

### 3. Data Type System
- **Bit-width Calculation**: Compile-time evaluation of `data{width:alignment}`
- **Alignment Constraints**: Memory layout optimization
- **Type Compatibility**: Rules for type conversion and promotion

## Performance Considerations

### 1. Memory Efficiency
- **Node Size Optimization**: Minimize memory footprint per node
- **Shared Immutable Data**: Share common subtrees where possible
- **Lazy Evaluation**: Defer expensive computations until needed

### 2. Traversal Performance
- **Cache-Friendly Layout**: Optimize for CPU cache performance
- **Efficient Iteration**: Fast child node enumeration
- **Parallel Processing**: Support for parallel analysis passes

## Extensibility and Future-Proofing

### 1. Language Evolution
- **Plugin Architecture**: Support for language extensions
- **Backward Compatibility**: Handle older language versions
- **Feature Flags**: Enable/disable experimental features

### 2. Tool Integration
- **Serialization**: Support for AST persistence and transfer
- **Language Server Protocol**: Integration with LSP for IDE support
- **Static Analysis**: Foundation for linting and analysis tools

## Implementation Guidelines

### 1. Node Hierarchy
- **Abstract Base Classes**: Common interface for all AST nodes
- **Specific Node Types**: Concrete implementations for each construct
- **Node Factories**: Centralized creation with validation

### 2. Type Safety
- **Strong Typing**: Leverage language type system for AST correctness
- **Validation**: Built-in invariant checking
- **Error Handling**: Graceful handling of malformed ASTs